---
/**
 * PerfBooster.astro â€” one-drop performance helper for Astro
 *
 * What it does:
 *  - Adds preconnect/dns-prefetch hints
 *  - Elevates LCP image priority (via selector or data-lcp)
 *  - Defers non-critical CSS (data-defer-css, auto-detect Font Awesome CDN)
 *  - Lazy-unveils offscreen images/iframes/backgrounds via data-*
 *  - Dynamically imports heavy widgets near viewport (data-import/data-init)
 *  - Prefetches next-page links & optional next carousel image
 *  - Skips layout/paint for offscreen sections via .defer-section
 *
 * Usage:
 *  1) Import once in your base layout and render before </body>.
 *     import PerfBooster from "@/components/PerfBooster.astro";
 *     <PerfBooster />
 *  2) (Optional) Mark hero/LCP image: <img data-lcp ...>
 *  3) For lazy media: data-src, data-srcset, data-sizes, data-bg
 *  4) Wrap heavy sections with class="defer-section" (content-visibility)
 *  5) Add data-defer-css on non-critical <link rel="stylesheet"> (or rely on FA auto-detect)
 *  6) Lazy external scripts with <script data-lazy-src="..."></script>
 */

export interface Props {
  preconnect?: string[];
  lcpSelector?: string;
  lcpSrc?: string;
  lcpSrcset?: string;
  lcpSizes?: string;
  /** Placeholder width/height for offscreen sections, e.g. "600px 800px" */
  containSize?: string;
  /** Selector for non-critical CSS links to defer */
  deferCssSelectors?: string;
}

const {
  preconnect = [
    "https://test.amrita-fashions.com",
    "https://fonts.googleapis.com",
    "https://fonts.gstatic.com",
    "https://cdnjs.cloudflare.com"
  ],
  lcpSelector = 'img[data-lcp], .hero img, img.hero',
  lcpSrc,
  lcpSrcset,
  lcpSizes,
  containSize = "600px 800px",
  deferCssSelectors = 'link[data-defer-css], link[href*="fontawesome"]',
} = Astro.props as Props;
---

<astro:head>
  {preconnect.map((h) => (
    <link rel="preconnect" href={h} crossorigin="anonymous" />
  ))}
  {preconnect.map((h) => (
    <link rel="dns-prefetch" href={h} />
  ))}

  {lcpSrc && (
    <link
      rel="preload"
      as="image"
      href={lcpSrc}
      {...(lcpSrcset ? { imagesrcset: lcpSrcset } : {})}
      {...(lcpSizes ? { imagesizes: lcpSizes } : {})}
      fetchpriority="high"
    />
  )}

  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <meta name="color-scheme" content="light dark" />
</astro:head>

<!--
  Use define:vars to pass containSize into CSS as --containSize.
  This avoids the CSS syntax error from {{containSize}}.
-->
<style is:global define:vars={{ containSize }}>
  /* Skip layout/paint for offscreen blocks until scrolled into view */
  .defer-section,
  [data-defer-section] {
    content-visibility: auto;
    contain-intrinsic-size: var(--containSize); /* width height placeholder */
  }

  /* Sensible defaults for images (avoid layout shifts) */
  img[loading="lazy"] {
    max-width: 100%;
    height: auto;
  }

  /* Lightweight skeleton utility (opt-in with data-skeleton) */
  [data-skeleton] {
    background: linear-gradient(
      90deg,
      rgba(0, 0, 0, 0.06) 25%,
      rgba(0, 0, 0, 0.12) 37%,
      rgba(0, 0, 0, 0.06) 63%
    );
    background-size: 200px 100%;
    animation: sk 1.1s infinite linear;
  }

  @keyframes sk {
    0% {
      background-position: -200px 0;
    }
    100% {
      background-position: calc(200px + 100%) 0;
    }
  }
</style>

<script is:inline>
(() => {
  const ROOT_MARGIN = "300px";

  // Inject server-side values safely into inline JS
  const LCP_SELECTOR = JSON.parse('{JSON.stringify(lcpSelector)}');
  const DEFER_CSS_SEL = JSON.parse('{JSON.stringify(deferCssSelectors)}');

  // 1) Defer selected non-critical CSS (opt-in) and auto-handle Font Awesome CDN
  const inHeadDeferCSS = () => {
    try {
      document.querySelectorAll(DEFER_CSS_SEL).forEach((link) => {
        if (link.rel !== "stylesheet" || link.dataset.perfHandled) return;

        // Preload so it downloads ASAP but doesn't block FCP
        const preload = document.createElement("link");
        preload.rel = "preload";
        preload.as = "style";
        preload.href = link.href;
        document.head.appendChild(preload);

        // Apply stylesheet after paint
        link.media = "print";
        link.onload = () => {
          link.media = "all";
        };
        link.dataset.perfHandled = "1";
      });
    } catch {
      /* ignore */
    }
  };

  // 2) Boost LCP: ensure hero image is not lazy and has high priority
  const setLcpPriority = () => {
    try {
      const el = document.querySelector(LCP_SELECTOR);
      if (el && el.tagName === "IMG") {
        el.removeAttribute("loading");
        el.setAttribute("fetchpriority", "high");
        el.decoding = "async";
      }
    } catch {
      /* ignore */
    }
  };

  // 3) Lazy unveil media & backgrounds with IntersectionObserver
  const ioSupported = "IntersectionObserver" in window;
  const mediaOptions = { rootMargin: ROOT_MARGIN, threshold: 0.01 };

  const revealMedia = (el) => {
    const src = el.getAttribute("data-src");
    const srcset = el.getAttribute("data-srcset");
    const sizes = el.getAttribute("data-sizes");

    if (src) {
      el.src = src;
      el.removeAttribute("data-src");
    }
    if (srcset) {
      el.srcset = srcset;
      el.removeAttribute("data-srcset");
    }
    if (sizes) {
      el.sizes = sizes;
      el.removeAttribute("data-sizes");
    }

    if (!el.hasAttribute("loading")) el.setAttribute("loading", "lazy");
    if (!el.hasAttribute("decoding")) el.setAttribute("decoding", "async");
    if ("fetchPriority" in el && !el.hasAttribute("fetchpriority")) {
      el.setAttribute("fetchpriority", "low");
    }
  };

  const revealBg = (el) => {
    const bg = el.getAttribute("data-bg");
    if (bg) {
      el.style.backgroundImage = `url("${bg}")`;
      el.removeAttribute("data-bg");
    }
  };

  // 4) Mount heavy widgets only when near viewport
  const mountModule = async (el) => {
    const mod = el.getAttribute("data-import");
    const fn = el.getAttribute("data-init");
    if (!mod) return;
    try {
      const m = await import(/* @vite-ignore */ mod);
      if (fn && typeof m[fn] === "function") m[fn](el);
      else if (typeof m.default === "function") m.default(el);
      el.removeAttribute("data-import");
      el.removeAttribute("data-init");
    } catch (e) {
      console.warn("[PerfBooster] import failed", mod, e);
    }
  };

  // 5) Prefetch near-viewport links & next carousel image (data-next-src)
  const prefetchLink = (a) => {
    if (!a || a.dataset.prefetched) return;
    const href = a.href;
    if (!href || href.indexOf(location.origin) !== 0) return; // same-origin only
    const l = document.createElement("link");
    l.rel = "prefetch";
    l.href = href;
    l.as = "document";
    document.head.appendChild(l);
    a.dataset.prefetched = "1";
  };

  const bind = () => {
    inHeadDeferCSS();
    setLcpPriority();

    if (!ioSupported) return;

    const mediaObserver = new IntersectionObserver((entries, obs) => {
      for (const e of entries) {
        if (!e.isIntersecting) continue;
        const t = e.target;
        if (t.tagName === "IMG" || t.tagName === "IFRAME") {
          revealMedia(t);
        } else {
          revealBg(t);
        }
        obs.unobserve(t);
      }
    }, mediaOptions);

    const widgetObserver = new IntersectionObserver((entries, obs) => {
      for (const e of entries) {
        if (!e.isIntersecting) continue;
        mountModule(e.target);
        obs.unobserve(e.target);
      }
    }, mediaOptions);

    const prefetchObserver = new IntersectionObserver((entries, obs) => {
      for (const e of entries) {
        if (!e.isIntersecting) continue;
        const el = e.target;
        const nextSrc = el.getAttribute("data-next-src");

        if (nextSrc) {
          const im = new Image();
          im.decoding = "async";
          // @ts-ignore
          if ("fetchPriority" in im) im.fetchPriority = "low";
          im.src = nextSrc;
          el.removeAttribute("data-next-src");
        }

        if (el.tagName === "A") prefetchLink(el);
        obs.unobserve(el);
      }
    }, { rootMargin: "600px" });

    document
      .querySelectorAll('img[data-src], img[data-srcset], img[data-sizes], iframe[data-src]')
      .forEach((el) => mediaObserver.observe(el));

    document.querySelectorAll("[data-bg]").forEach((el) => mediaObserver.observe(el));
    document.querySelectorAll("[data-import]").forEach((el) => widgetObserver.observe(el));
    document
      .querySelectorAll("[data-next-src], a[href^='/']")
      .forEach((el) => prefetchObserver.observe(el));
  };

  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", bind, { once: true });
  } else {
    bind();
  }

  // 6) Idle-load external scripts declared as placeholders
  const idle = window.requestIdleCallback || ((fn) => setTimeout(fn, 1));
  idle(() => {
    document.querySelectorAll("script[data-lazy-src]").forEach((s) => {
      const sc = document.createElement("script");
      sc.src = s.getAttribute("data-lazy-src");
      sc.async = true;
      s.replaceWith(sc);
    });
  });
})();
</script>
